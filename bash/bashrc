# My standard interactive shell config files
source ~/.standard.sh

# TODO: Document a bit

# My pure-like bash prompt!

parse_git_status() {
    STATUS="$(git status --porcelain=v2 --branch 2> /dev/null)"
    if [ -z "$STATUS" ]; then
        return
    fi

    BRANCH="$(echo "$STATUS" | grep "branch.head" | awk '{print $NF}')"

    AHEAD_BEHIND="$(echo "$STATUS" | grep "branch.ab")"
    # vim highlights these are errors. They're not
    AHEAD="$(echo "$AHEAD_BEHIND" | grep -o '+[0-9]')"
    AHEAD="${AHEAD#?}"
    BEHIND="$(echo "$AHEAD_BEHIND" | grep -o '\-[0-9]')"
    BEHIND="${BEHIND#?}"
    if [ "$AHEAD" -ne "0" ]; then
        arrows+=" ⇡"
        [ "$AHEAD" -ne "1" ] && arrows+="$AHEAD"
    fi
    if [ "$BEHIND" -ne "0" ]; then
        arrows+=" ⇡"
        [ "$BEHIND" -ne "1" ] && arrows+="$BEHIND"
    fi

    bits=''
    # regex to find => bit to flag if found
    declare -A BIT_MAP=(
        ['^[12]']='*'
        ['^u']='+'
        ['^?']='?'
    )
    for regex in "${!BIT_MAP[@]}"; do
        # We have to pipe the subshells output into a black hole since we only
        # want its return value
        (echo "$STATUS" | grep "$regex") &> /dev/null \
            && bits+="${BIT_MAP[$regex]}"
    done

    echo " \e[38m${BRANCH}${bits}\e[36m${arrows}"
}

last_status() {
    RETVAL=$?
    if [ "$RETVAL" -eq "0" ]; then
        echo -e '\e[35m'
    else
        echo -e '\e[31m'
    fi
}

make_prompt() {
    [ "$?" -eq 0 ] && STATUS_COLOR="\e[35m" || STATUS_COLOR="\e[31m"

    # I color the path yellow so I know it's bash
    export PS1="\n\e[33m\w$(parse_git_status)\n${STATUS_COLOR}❯\e[0m "
}

export PROMPT_COMMAND=make_prompt
